# !! mdx alone

```jsx !page rr
import Content from "./content.mdx"

export default function Page() {
  return <Content />
}
```

```mdx !input c
# Hello world

<MyComponent>

The Fellowship of the Ring

## !moria western gate

Speak, friend

</MyComponent>
```

```jsx !output rr
export default function MDXContent() {
  return (
    <>
      <h1>Hello world</h1>
      <MyComponent>
        <p>The Fellowship of the Ring</p>
        <h2>!moria western gate</h2>
        <p>Speak, friend</p>
      </MyComponent>
    </>
  )
}
```

## !note

Code Hike is mostly an MDX plugin.

And MDX is something that runs at build time and compile markdown files into javascript.

# !! mdx and output

```jsx !page rr
import Content from "./content.mdx"

export default function Page() {
  return <Content />
}
```

```mdx !input l
# Hello world

<MyComponent>

The Fellowship of the Ring

## !moria western gate

Speak, friend

</MyComponent>
```

```jsx !output r
export default function MDXContent() {
  return (
    <>
      <h1>Hello world</h1>
      <MyComponent>
        <p>The Fellowship of the Ring</p>
        <h2>!moria western gate</h2>
        <p>Speak, friend</p>
      </MyComponent>
    </>
  )
}
```

## !note

For example this is the output that we get from the MDX file on the left.

We have all the markdown nodes transformed into JSX.

# !! mdx output and page

```jsx !page r
import Content from "./content.mdx"

export default function Page() {
  return <Content />
}
```

```mdx !input ll
# Hello world

<MyComponent>

The Fellowship of the Ring

## !moria western gate

Speak, friend

</MyComponent>
```

```jsx !output l
export default function MDXContent() {
  return (
    <>
      <h1>Hello world</h1>
      <MyComponent>
        <p>The Fellowship of the Ring</p>
        <h2>!moria western gate</h2>
        <p>Speak, friend</p>
      </MyComponent>
    </>
  )
}
```

## !note

Then, from your code, when you want to render that MDXContent, you can import the mdx file and you will be importing that generated component, so you can render it where you want.

# !! mdx plugins

```jsx !page rr
import Content from "./content.mdx"

export default function Page() {
  return <Content />
}
```

```mdx !input l
# Hello world

<MyComponent>

The Fellowship of the Ring

## !moria western gate

Speak, friend

</MyComponent>
```

```jsx !output r
export default function MDXContent() {
  return (
    <>
      <h1>Hello world</h1>
      <MyComponent>
        <p>The Fellowship of the Ring</p>
        <h2>!moria western gate</h2>
        <p>Speak, friend</p>
      </MyComponent>
    </>
  )
}
```

## !note

MDX has plugins, maybe you've heard about remark or rehype plugins. With plugins we can transform some stuff during the compilation to change the output.

And that's what Code Hike does.

# !! mdx + ch

{/* prettier-ignore */}
```jsx !page rr
import Content from "./content.mdx"

export default function Page() {
  return <Content 
    components={{ MyComponent }} 
  />
}

function MyComponent(props) {
  return <div />
}
```

```mdx !input l
# Hello world

<MyComponent>

The Fellowship of the Ring

## !moria western gate

Speak, friend

</MyComponent>
```

```jsx !output r
export default function MDXContent() {
  return (
    <>
      <h1>Hello world</h1>
      <MyComponent
        moria={{
          title: "western gate",
          children: <p>Speak, friend</p>,
        }}
      >
        <p>The Fellowship of the Ring</p>
      </MyComponent>
    </>
  )
}
```

## !note

In this example, when we add the Code Hike plugin, it will find that `!moria` annotation and transform it into a prop of `MyComponent`.

This is what I call a block. And it has a title, which is the rest of the header after the annotation. And it has children, which are all the nodes that follow the header until the next block.

# !! lists

```mdx !input l
<MyComponent>

The Fellowship of the Ring

## !moria western gate

Speak, friend

## !!breakfasts first

Apple pancakes

## !!breakfasts second

Mushrooms

</MyComponent>
```

```jsx !output r
export default function MDXContent() {
  return (
    <MyComponent
      moria={{
        title: "western gate",
        children: <p>Speak, friend</p>,
      }}
      breakfasts={[
        {
          title: "first",
          children: <p>Apple pancakes</p>,
        },
        {
          title: "second",
          children: <p>Mushrooms</p>,
        },
      ]}
    >
      <p>The Fellowship of the Ring</p>
    </MyComponent>
  )
}
```

## !note

We can also have lists of blocks. Here the breakfasts annotation, starts with two exclamation marks instead of one, and this tells Code Hike that this should be a list of blocks. So MyComponent will receive an array of breakfasts.

# !! nesting

```mdx !input l
<MyComponent>

## !!breakfasts first

Apple pancakes

### !recipe foo

- Cut apples
- Mix batter

## !!breakfasts second

Mushrooms

</MyComponent>
```

```jsx !output r
export default function MDXContent() {
  return (
    <MyComponent
      breakfasts={[
        {
          title: "first",
          children: <p>Apple pancakes</p>,
          recipe: {
            title: "foo",
            children: (
              <ul>
                <li>Cut apples</li>
                <li>Mix batter</li>
              </ul>
            ),
          },
        },
        {
          title: "second",
          children: <p>Mushrooms</p>,
        },
      ]}
    >
      <p>The Fellowship of the Ring</p>
    </MyComponent>
  )
}
```

## !note

We can also nest blocks.

Here the recipe block is deeper than the breakfasts block, right? we have a level 2 header and then the recipe is a level 3 header.

So, this tells Code Hike that the recipe block is a child of the breakfast block.

And combining lists and nesting, makes it possible to represent complex structures.

# !! images, codeblocks, and paragraphs

````mdx !input l
<MyComponent>

The Fellowship of the Ring

!author Tolkien

![!cover Gandalf](/gandalf.jpg)

## !moria western gate

Speak, friend

```js !riddle mellon.js
speak("friend")
```

</MyComponent>
````

```jsx !output r
export default function MDXContent() {
  return (
    <MyComponent
      author="Tolkien"
      cover={{
        alt: "Gandalf",
        url: "/gandalf.jpg",
      }}
      moria={{
        title: "western gate",
        children: <p>Speak, friend</p>,
        riddle: {
          lang: "js",
          meta: "mellon.js",
          value: 'speak("friend")',
        },
      }}
    >
      <p>The Fellowship of the Ring</p>
    </MyComponent>
  )
}
```

## !note

Besides blocks, we can annotate other nodes.

If we put the annotation at the start of a paragraph, it will be transformed into a string prop.

We can also use it with images, so MyComponent will receive the alt and url.

And we can use it with code blocks, and here the component will have access to the language, meta, and code itself. There's also an option to syntax highlight the code, so we could have more stuff here but we'll leave that for later.

So this is the code generated by MDX and Code Hike. If we now go the implementation of MyComponent

# !! schemas

```jsx !output mh
export default function MDXContent() {
  return (
    <MyComponent
      breakfasts={[
        {
          title: "first",
          children: <p>Apple pancakes</p>,
          recipe: {
            title: "",
            children: (
              <ul>
                <li>Cut apples</li>
                <li>Mix batter</li>
              </ul>
            ),
          },
        },
        {
          title: "second",
          children: <p>Mushrooms</p>,
        },
      ]}
    >
      <p>The Fellowship of the Ring</p>
    </MyComponent>
  )
}
```

```jsx !page r
import { z } from "zod"
import { parseProps, Block, CodeBlock,
  ImageBlock } from "codehike/blocks"

const Schema = Block.extend({
  author: z.string(),
  cover: ImageBlock.optional(),
  moria: Block.extend({
    riddle: CodeBlock,
  }),
})

export function MyComponent(props) {
  const data = parseProps(props, Schema)
  ...
}
```

## !note

Here we can define a schema for the props of MyComponent.

This gives us two advantages:

One is autocompletion and all the editor tooling that comes with TypeScript.

The other advantage is that we are validating that the markdown follows the structure we expect.

For example, in this case we made the cover image optional, so we could have it or not. But the codeblock is required, if we miss it, we'll get an error.

# !! root

````mdx !input l
The Fellowship of the Ring

!author Tolkien

![!cover Gandalf](/gandalf.jpg)

## !moria western gate

Speak, friend

```js !riddle mellon.js
speak("friend")
```
````

```jsx !output mh
export default function MDXContent() {
  return (
    <MyComponent
      breakfasts={[
        {
          title: "first",
          children: <p>Apple pancakes</p>,
          recipe: {
            title: "",
            children: (
              <ul>
                <li>Cut apples</li>
                <li>Mix batter</li>
              </ul>
            ),
          },
        },
        {
          title: "second",
          children: <p>Mushrooms</p>,
        },
      ]}
    >
      <p>The Fellowship of the Ring</p>
    </MyComponent>
  )
}
```

```jsx !page r
import { z } from "zod"
import { parseRoot, Block, CodeBlock,
  ImageBlock } from "codehike/blocks"

const Schema = Block.extend({
  author: z.string(),
  cover: ImageBlock.optional(),
  moria: Block.extend({
    riddle: CodeBlock,
  }),
})

import Content from "./content.md"
export function Page() {
  const data = parseRoot(Content, Schema)
  ...
}
```

## !note

So far we've been using the annotated markdown inside a component, but we can also parse the markdown file and extract the data.

So here, instead of parsing the props we are parsing the actual import of the markdown file.

So why is this useful?

Well, first we can use plain markdown, I mean, no JSX.

And second, we are not limited to a component. You can use the markdown as data source. For example, let's say you have a blog, you can add a block to each post with an excerpt, and then when you list the posts, you can show the excerpt for each one.

Now let's see a real demo of all this.
